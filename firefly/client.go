// Package firefly provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.1.0 DO NOT EDIT.
package firefly

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	Firefly_iii_authScopes  = "firefly_iii_auth.Scopes"
	Local_bearer_authScopes = "local_bearer_auth.Scopes"
)

// Defines values for AccountTypeProperty.
const (
	AssetAccount          AccountTypeProperty = "Asset account"
	BeneficiaryAccount    AccountTypeProperty = "Beneficiary account"
	CashAccount           AccountTypeProperty = "Cash account"
	Debt                  AccountTypeProperty = "Debt"
	DefaultAccount        AccountTypeProperty = "Default account"
	ExpenseAccount        AccountTypeProperty = "Expense account"
	ImportAccount         AccountTypeProperty = "Import account"
	InitialBalanceAccount AccountTypeProperty = "Initial balance account"
	Loan                  AccountTypeProperty = "Loan"
	Mortgage              AccountTypeProperty = "Mortgage"
	ReconciliationAccount AccountTypeProperty = "Reconciliation account"
	RevenueAccount        AccountTypeProperty = "Revenue account"
)

// Defines values for AttachableType.
const (
	Account            AttachableType = "Account"
	Bill               AttachableType = "Bill"
	Budget             AttachableType = "Budget"
	PiggyBank          AttachableType = "PiggyBank"
	Tag                AttachableType = "Tag"
	TransactionJournal AttachableType = "TransactionJournal"
)

// Defines values for TransactionTypeProperty.
const (
	Deposit        TransactionTypeProperty = "deposit"
	OpeningBalance TransactionTypeProperty = "opening balance"
	Reconciliation TransactionTypeProperty = "reconciliation"
	Transfer       TransactionTypeProperty = "transfer"
	Withdrawal     TransactionTypeProperty = "withdrawal"
)

// AccountTypeProperty defines model for AccountTypeProperty.
type AccountTypeProperty string

// AttachableType The object class to which the attachment must be linked.
type AttachableType string

// Attachment defines model for Attachment.
type Attachment struct {
	// AttachableId ID of the model this attachment is linked to.
	AttachableId string `json:"attachable_id"`

	// AttachableType The object class to which the attachment must be linked.
	AttachableType AttachableType `json:"attachable_type"`
	CreatedAt      *time.Time     `json:"created_at,omitempty"`
	DownloadUrl    *string        `json:"download_url,omitempty"`
	Filename       string         `json:"filename"`

	// Md5 MD5 hash of the file for basic duplicate detection.
	Md5       *string    `json:"md5,omitempty"`
	Mime      *string    `json:"mime,omitempty"`
	Notes     *string    `json:"notes"`
	Size      *int32     `json:"size,omitempty"`
	Title     *string    `json:"title"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
	UploadUrl *string    `json:"upload_url,omitempty"`
}

// AttachmentArray defines model for AttachmentArray.
type AttachmentArray struct {
	Data []AttachmentRead `json:"data"`
	Meta Meta             `json:"meta"`
}

// AttachmentRead defines model for AttachmentRead.
type AttachmentRead struct {
	Attributes Attachment `json:"attributes"`
	Id         string     `json:"id"`
	Links      ObjectLink `json:"links"`

	// Type Immutable value
	Type string `json:"type"`
}

// AttachmentSingle defines model for AttachmentSingle.
type AttachmentSingle struct {
	Data AttachmentRead `json:"data"`
}

// AttachmentStore defines model for AttachmentStore.
type AttachmentStore struct {
	// AttachableId ID of the model this attachment is linked to.
	AttachableId string `json:"attachable_id"`

	// AttachableType The object class to which the attachment must be linked.
	AttachableType AttachableType `json:"attachable_type"`
	Filename       string         `json:"filename"`
	Notes          *string        `json:"notes"`
	Title          *string        `json:"title,omitempty"`
}

// BadRequestResponse defines model for BadRequestResponse.
type BadRequestResponse struct {
	Exception *string `json:"exception,omitempty"`
	Message   *string `json:"message,omitempty"`
}

// InternalExceptionResponse defines model for InternalExceptionResponse.
type InternalExceptionResponse struct {
	Exception *string `json:"exception,omitempty"`
	Message   *string `json:"message,omitempty"`
}

// Meta defines model for Meta.
type Meta struct {
	Pagination *struct {
		Count       *int `json:"count,omitempty"`
		CurrentPage *int `json:"current_page,omitempty"`
		PerPage     *int `json:"per_page,omitempty"`
		Total       *int `json:"total,omitempty"`
		TotalPages  *int `json:"total_pages,omitempty"`
	} `json:"pagination,omitempty"`
}

// NotFoundResponse defines model for NotFoundResponse.
type NotFoundResponse struct {
	Exception *string `json:"exception,omitempty"`
	Message   *string `json:"message,omitempty"`
}

// ObjectLink defines model for ObjectLink.
type ObjectLink struct {
	N0 *struct {
		Rel *string `json:"rel,omitempty"`
		Uri *string `json:"uri,omitempty"`
	} `json:"0,omitempty"`
	Self *string `json:"self,omitempty"`
}

// PageLink defines model for PageLink.
type PageLink struct {
	First *string `json:"first,omitempty"`
	Last  *string `json:"last,omitempty"`
	Next  *string `json:"next"`
	Prev  *string `json:"prev"`
	Self  *string `json:"self,omitempty"`
}

// Transaction defines model for Transaction.
type Transaction struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// GroupTitle Title of the transaction if it has been split in more than one piece. Empty otherwise.
	GroupTitle   *string            `json:"group_title"`
	Transactions []TransactionSplit `json:"transactions"`
	UpdatedAt    *time.Time         `json:"updated_at,omitempty"`

	// User User ID
	User *string `json:"user,omitempty"`
}

// TransactionArray defines model for TransactionArray.
type TransactionArray struct {
	Data  []TransactionRead `json:"data"`
	Links PageLink          `json:"links"`
	Meta  Meta              `json:"meta"`
}

// TransactionRead defines model for TransactionRead.
type TransactionRead struct {
	Attributes Transaction `json:"attributes"`
	Id         string      `json:"id"`
	Links      ObjectLink  `json:"links"`

	// Type Immutable value
	Type string `json:"type"`
}

// TransactionSingle defines model for TransactionSingle.
type TransactionSingle struct {
	Data TransactionRead `json:"data"`
}

// TransactionSplit defines model for TransactionSplit.
type TransactionSplit struct {
	// Amount Amount of the transaction.
	Amount string `json:"amount"`

	// BillId Optional. Use either this or the bill_name
	BillId *string `json:"bill_id"`

	// BillName Optional. Use either this or the bill_id
	BillName *string    `json:"bill_name"`
	BookDate *time.Time `json:"book_date"`

	// BudgetId The budget ID for this transaction.
	BudgetId *string `json:"budget_id"`

	// BudgetName The name of the budget to be used. If the budget name is unknown, the ID will be used or the value will be ignored.
	BudgetName *string `json:"budget_name"`

	// BunqPaymentId Internal ID of bunq transaction. DEPRECATED
	BunqPaymentId *string `json:"bunq_payment_id"`

	// CategoryId The category ID for this transaction.
	CategoryId *string `json:"category_id"`

	// CategoryName The name of the category to be used. If the category is unknown, it will be created. If the ID and the name point to different categories, the ID overrules the name.
	CategoryName *string `json:"category_name"`

	// CurrencyCode Currency code. Default is the source account's currency, or the user's default currency. Can be used instead of currency_id.
	CurrencyCode *string `json:"currency_code"`

	// CurrencyDecimalPlaces Number of decimals used in this currency.
	CurrencyDecimalPlaces *int32 `json:"currency_decimal_places,omitempty"`

	// CurrencyId Currency ID. Default is the source account's currency, or the user's default currency. Can be used instead of currency_code.
	CurrencyId     *string `json:"currency_id"`
	CurrencyName   *string `json:"currency_name,omitempty"`
	CurrencySymbol *string `json:"currency_symbol,omitempty"`

	// Date Date of the transaction
	Date time.Time `json:"date"`

	// Description Description of the transaction.
	Description     string  `json:"description"`
	DestinationIban *string `json:"destination_iban"`

	// DestinationId ID of the destination account. For a deposit or a transfer, this must always be an asset account. For withdrawals this must be an expense account.
	DestinationId *string `json:"destination_id"`

	// DestinationName Name of the destination account. You can submit the name instead of the ID. For everything except transfers, the account will be auto-generated if unknown, so submitting a name is enough.
	DestinationName *string              `json:"destination_name"`
	DestinationType *AccountTypeProperty `json:"destination_type,omitempty"`
	DueDate         *time.Time           `json:"due_date"`

	// ExternalId Reference to external ID in other systems.
	ExternalId *string `json:"external_id"`

	// ExternalUrl External, custom URL for this transaction.
	ExternalUrl *string `json:"external_url"`

	// ForeignAmount The amount in a foreign currency.
	ForeignAmount *string `json:"foreign_amount"`

	// ForeignCurrencyCode Currency code of the foreign currency. Default is NULL. Can be used instead of the foreign_currency_id, but this or the ID is required when submitting a foreign amount.
	ForeignCurrencyCode *string `json:"foreign_currency_code"`

	// ForeignCurrencyDecimalPlaces Number of decimals in the currency
	ForeignCurrencyDecimalPlaces *int32 `json:"foreign_currency_decimal_places"`

	// ForeignCurrencyId Currency ID of the foreign currency. Default is null. Is required when you submit a foreign amount.
	ForeignCurrencyId     *string `json:"foreign_currency_id"`
	ForeignCurrencySymbol *string `json:"foreign_currency_symbol"`

	// HasAttachments If the transaction has attachments.
	HasAttachments *bool `json:"has_attachments,omitempty"`

	// ImportHashV2 Hash value of original import transaction (for duplicate detection).
	ImportHashV2 *string    `json:"import_hash_v2"`
	InterestDate *time.Time `json:"interest_date"`

	// InternalReference Reference to internal reference of other systems.
	InternalReference *string    `json:"internal_reference"`
	InvoiceDate       *time.Time `json:"invoice_date"`

	// Latitude Latitude of the transaction's location, if applicable. Can be used to draw a map.
	Latitude *float64 `json:"latitude"`

	// Longitude Latitude of the transaction's location, if applicable. Can be used to draw a map.
	Longitude *float64 `json:"longitude"`
	Notes     *string  `json:"notes"`

	// Order Order of this entry in the list of transactions.
	Order *int32 `json:"order"`

	// OriginalSource System generated identifier for original creator of transaction.
	OriginalSource *string    `json:"original_source"`
	PaymentDate    *time.Time `json:"payment_date"`
	ProcessDate    *time.Time `json:"process_date"`

	// Reconciled If the transaction has been reconciled already. When you set this, the amount can no longer be edited by the user.
	Reconciled *bool `json:"reconciled,omitempty"`

	// RecurrenceCount The # of the current transaction created under this recurrence.
	RecurrenceCount *int32 `json:"recurrence_count"`

	// RecurrenceId Reference to recurrence that made the transaction.
	RecurrenceId *string `json:"recurrence_id"`

	// RecurrenceTotal Total number of transactions expected to be created by this recurrence repetition. Will be 0 if infinite.
	RecurrenceTotal *int32 `json:"recurrence_total"`

	// SepaBatchId SEPA Batch ID
	SepaBatchId *string `json:"sepa_batch_id"`

	// SepaCc SEPA Clearing Code
	SepaCc *string `json:"sepa_cc"`

	// SepaCi SEPA Creditor Identifier
	SepaCi *string `json:"sepa_ci"`

	// SepaCountry SEPA Country
	SepaCountry *string `json:"sepa_country"`

	// SepaCtId SEPA end-to-end Identifier
	SepaCtId *string `json:"sepa_ct_id"`

	// SepaCtOp SEPA Opposing Account Identifier
	SepaCtOp *string `json:"sepa_ct_op"`

	// SepaDb SEPA mandate identifier
	SepaDb *string `json:"sepa_db"`

	// SepaEp SEPA External Purpose indicator
	SepaEp     *string `json:"sepa_ep"`
	SourceIban *string `json:"source_iban"`

	// SourceId ID of the source account. For a withdrawal or a transfer, this must always be an asset account. For deposits, this must be a revenue account.
	SourceId *string `json:"source_id"`

	// SourceName Name of the source account. For a withdrawal or a transfer, this must always be an asset account. For deposits, this must be a revenue account. Can be used instead of the source_id. If the transaction is a deposit, the source_name can be filled in freely: the account will be created based on the name.
	SourceName *string              `json:"source_name"`
	SourceType *AccountTypeProperty `json:"source_type,omitempty"`

	// Tags Array of tags.
	Tags *[]string `json:"tags"`

	// TransactionJournalId ID of the underlying transaction journal. Each transaction consists of a transaction group (see the top ID) and one or more journals
	// making up the splits of the transaction.
	TransactionJournalId *string                 `json:"transaction_journal_id,omitempty"`
	Type                 TransactionTypeProperty `json:"type"`

	// User User ID
	User *string `json:"user,omitempty"`

	// ZoomLevel Zoom level for the map, if drawn. This to set the box right. Unfortunately this is a proprietary value because each map provider has different zoom levels.
	ZoomLevel *int32 `json:"zoom_level"`
}

// TransactionSplitStore defines model for TransactionSplitStore.
type TransactionSplitStore struct {
	// Amount Amount of the transaction.
	Amount string `json:"amount"`

	// BillId Optional. Use either this or the bill_name
	BillId *string `json:"bill_id"`

	// BillName Optional. Use either this or the bill_id
	BillName *string    `json:"bill_name"`
	BookDate *time.Time `json:"book_date"`

	// BudgetId The budget ID for this transaction.
	BudgetId *string `json:"budget_id"`

	// BudgetName The name of the budget to be used. If the budget name is unknown, the ID will be used or the value will be ignored.
	BudgetName *string `json:"budget_name"`

	// BunqPaymentId Internal ID of bunq transaction. Field is no longer used but still works.
	BunqPaymentId *string `json:"bunq_payment_id"`

	// CategoryId The category ID for this transaction.
	CategoryId *string `json:"category_id"`

	// CategoryName The name of the category to be used. If the category is unknown, it will be created. If the ID and the name point to different categories, the ID overrules the name.
	CategoryName *string `json:"category_name"`

	// CurrencyCode Currency code. Default is the source account's currency, or the user's default currency. The value you submit may be overruled by the source or destination account.
	CurrencyCode *string `json:"currency_code"`

	// CurrencyId Currency ID. Default is the source account's currency, or the user's default currency. The value you submit may be overruled by the source or destination account.
	CurrencyId *string `json:"currency_id"`

	// Date Date of the transaction
	Date time.Time `json:"date"`

	// Description Description of the transaction.
	Description string `json:"description"`

	// DestinationId ID of the destination account. For a deposit or a transfer, this must always be an asset account. For withdrawals this must be an expense account.
	DestinationId *string `json:"destination_id"`

	// DestinationName Name of the destination account. You can submit the name instead of the ID. For everything except transfers, the account will be auto-generated if unknown, so submitting a name is enough.
	DestinationName *string    `json:"destination_name"`
	DueDate         *time.Time `json:"due_date"`

	// ExternalId Reference to external ID in other systems.
	ExternalId *string `json:"external_id"`

	// ExternalUrl External, custom URL for this transaction.
	ExternalUrl *string `json:"external_url"`

	// ForeignAmount The amount in a foreign currency.
	ForeignAmount *string `json:"foreign_amount"`

	// ForeignCurrencyCode Currency code of the foreign currency. Default is NULL. Can be used instead of the foreign_currency_id, but this or the ID is required when submitting a foreign amount.
	ForeignCurrencyCode *string `json:"foreign_currency_code"`

	// ForeignCurrencyId Currency ID of the foreign currency. Default is null. Is required when you submit a foreign amount.
	ForeignCurrencyId *string    `json:"foreign_currency_id"`
	InterestDate      *time.Time `json:"interest_date"`

	// InternalReference Reference to internal reference of other systems.
	InternalReference *string    `json:"internal_reference"`
	InvoiceDate       *time.Time `json:"invoice_date"`
	Notes             *string    `json:"notes"`

	// Order Order of this entry in the list of transactions.
	Order       *int32     `json:"order"`
	PaymentDate *time.Time `json:"payment_date"`

	// PiggyBankId Optional. Use either this or the piggy_bank_name
	PiggyBankId *int32 `json:"piggy_bank_id"`

	// PiggyBankName Optional. Use either this or the piggy_bank_id
	PiggyBankName *string    `json:"piggy_bank_name"`
	ProcessDate   *time.Time `json:"process_date"`

	// Reconciled If the transaction has been reconciled already. When you set this, the amount can no longer be edited by the user.
	Reconciled *bool `json:"reconciled,omitempty"`

	// SepaBatchId SEPA Batch ID
	SepaBatchId *string `json:"sepa_batch_id"`

	// SepaCc SEPA Clearing Code
	SepaCc *string `json:"sepa_cc"`

	// SepaCi SEPA Creditor Identifier
	SepaCi *string `json:"sepa_ci"`

	// SepaCountry SEPA Country
	SepaCountry *string `json:"sepa_country"`

	// SepaCtId SEPA end-to-end Identifier
	SepaCtId *string `json:"sepa_ct_id"`

	// SepaCtOp SEPA Opposing Account Identifier
	SepaCtOp *string `json:"sepa_ct_op"`

	// SepaDb SEPA mandate identifier
	SepaDb *string `json:"sepa_db"`

	// SepaEp SEPA External Purpose indicator
	SepaEp *string `json:"sepa_ep"`

	// SourceId ID of the source account. For a withdrawal or a transfer, this must always be an asset account. For deposits, this must be a revenue account.
	SourceId *string `json:"source_id"`

	// SourceName Name of the source account. For a withdrawal or a transfer, this must always be an asset account. For deposits, this must be a revenue account. Can be used instead of the source_id. If the transaction is a deposit, the source_name can be filled in freely: the account will be created based on the name.
	SourceName *string `json:"source_name"`

	// Tags Array of tags.
	Tags *[]string               `json:"tags"`
	Type TransactionTypeProperty `json:"type"`
}

// TransactionStore defines model for TransactionStore.
type TransactionStore struct {
	// ApplyRules Whether or not to apply rules when submitting transaction.
	ApplyRules *bool `json:"apply_rules,omitempty"`

	// ErrorIfDuplicateHash Break if the submitted transaction exists already.
	ErrorIfDuplicateHash *bool `json:"error_if_duplicate_hash,omitempty"`

	// FireWebhooks Whether or not to fire the webhooks that are related to this event.
	FireWebhooks *bool `json:"fire_webhooks,omitempty"`

	// GroupTitle Title of the transaction if it has been split in more than one piece. Empty otherwise.
	GroupTitle   *string                 `json:"group_title"`
	Transactions []TransactionSplitStore `json:"transactions"`
}

// TransactionTypeProperty defines model for TransactionTypeProperty.
type TransactionTypeProperty string

// UnauthenticatedResponse defines model for UnauthenticatedResponse.
type UnauthenticatedResponse struct {
	Exception *string `json:"exception,omitempty"`
	Message   *string `json:"message,omitempty"`
}

// ValidationErrorResponse defines model for ValidationErrorResponse.
type ValidationErrorResponse struct {
	Errors *struct {
		Blocked     *[]string `json:"blocked,omitempty"`
		BlockedCode *[]string `json:"blocked_code,omitempty"`
		Date        *[]string `json:"date,omitempty"`
		Email       *[]string `json:"email,omitempty"`
		End         *[]string `json:"end,omitempty"`
		Iban        *[]string `json:"iban,omitempty"`
		Name        *[]string `json:"name,omitempty"`
		Role        *[]string `json:"role,omitempty"`
		Start       *[]string `json:"start,omitempty"`
		Type        *[]string `json:"type,omitempty"`
	} `json:"errors,omitempty"`
	Message *string `json:"message,omitempty"`
}

// StoreAttachmentParams defines parameters for StoreAttachment.
type StoreAttachmentParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// UploadAttachmentParams defines parameters for UploadAttachment.
type UploadAttachmentParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// SearchTransactionsParams defines parameters for SearchTransactions.
type SearchTransactionsParams struct {
	// Limit Number of items per page. The default pagination is per 50 items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Page Page number. The default pagination is per 50 items.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// Query The query you wish to search for.
	Query string `form:"query" json:"query"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// StoreTransactionParams defines parameters for StoreTransaction.
type StoreTransactionParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// ListAttachmentByTransactionParams defines parameters for ListAttachmentByTransaction.
type ListAttachmentByTransactionParams struct {
	// Limit Number of items per page. The default pagination is per 50 items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Page Page number. The default pagination is per 50 items.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// StoreAttachmentJSONRequestBody defines body for StoreAttachment for application/json ContentType.
type StoreAttachmentJSONRequestBody = AttachmentStore

// StoreAttachmentFormdataRequestBody defines body for StoreAttachment for application/x-www-form-urlencoded ContentType.
type StoreAttachmentFormdataRequestBody = AttachmentStore

// StoreTransactionJSONRequestBody defines body for StoreTransaction for application/json ContentType.
type StoreTransactionJSONRequestBody = TransactionStore

// StoreTransactionFormdataRequestBody defines body for StoreTransaction for application/x-www-form-urlencoded ContentType.
type StoreTransactionFormdataRequestBody = TransactionStore

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// StoreAttachmentWithBody request with any body
	StoreAttachmentWithBody(ctx context.Context, params *StoreAttachmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StoreAttachment(ctx context.Context, params *StoreAttachmentParams, body StoreAttachmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	StoreAttachmentWithFormdataBody(ctx context.Context, params *StoreAttachmentParams, body StoreAttachmentFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadAttachmentWithBody request with any body
	UploadAttachmentWithBody(ctx context.Context, id string, params *UploadAttachmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchTransactions request
	SearchTransactions(ctx context.Context, params *SearchTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StoreTransactionWithBody request with any body
	StoreTransactionWithBody(ctx context.Context, params *StoreTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StoreTransaction(ctx context.Context, params *StoreTransactionParams, body StoreTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	StoreTransactionWithFormdataBody(ctx context.Context, params *StoreTransactionParams, body StoreTransactionFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAttachmentByTransaction request
	ListAttachmentByTransaction(ctx context.Context, id string, params *ListAttachmentByTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) StoreAttachmentWithBody(ctx context.Context, params *StoreAttachmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreAttachmentRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreAttachment(ctx context.Context, params *StoreAttachmentParams, body StoreAttachmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreAttachmentRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreAttachmentWithFormdataBody(ctx context.Context, params *StoreAttachmentParams, body StoreAttachmentFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreAttachmentRequestWithFormdataBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadAttachmentWithBody(ctx context.Context, id string, params *UploadAttachmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadAttachmentRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchTransactions(ctx context.Context, params *SearchTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchTransactionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreTransactionWithBody(ctx context.Context, params *StoreTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreTransactionRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreTransaction(ctx context.Context, params *StoreTransactionParams, body StoreTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreTransactionRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreTransactionWithFormdataBody(ctx context.Context, params *StoreTransactionParams, body StoreTransactionFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreTransactionRequestWithFormdataBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAttachmentByTransaction(ctx context.Context, id string, params *ListAttachmentByTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAttachmentByTransactionRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewStoreAttachmentRequest calls the generic StoreAttachment builder with application/json body
func NewStoreAttachmentRequest(server string, params *StoreAttachmentParams, body StoreAttachmentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStoreAttachmentRequestWithBody(server, params, "application/json", bodyReader)
}

// NewStoreAttachmentRequestWithFormdataBody calls the generic StoreAttachment builder with application/x-www-form-urlencoded body
func NewStoreAttachmentRequestWithFormdataBody(server string, params *StoreAttachmentParams, body StoreAttachmentFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewStoreAttachmentRequestWithBody(server, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewStoreAttachmentRequestWithBody generates requests for StoreAttachment with any type of body
func NewStoreAttachmentRequestWithBody(server string, params *StoreAttachmentParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/attachments")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewUploadAttachmentRequestWithBody generates requests for UploadAttachment with any type of body
func NewUploadAttachmentRequestWithBody(server string, id string, params *UploadAttachmentParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/attachments/%s/upload", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewSearchTransactionsRequest generates requests for SearchTransactions
func NewSearchTransactionsRequest(server string, params *SearchTransactionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/search/transactions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, params.Query); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewStoreTransactionRequest calls the generic StoreTransaction builder with application/json body
func NewStoreTransactionRequest(server string, params *StoreTransactionParams, body StoreTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStoreTransactionRequestWithBody(server, params, "application/json", bodyReader)
}

// NewStoreTransactionRequestWithFormdataBody calls the generic StoreTransaction builder with application/x-www-form-urlencoded body
func NewStoreTransactionRequestWithFormdataBody(server string, params *StoreTransactionParams, body StoreTransactionFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewStoreTransactionRequestWithBody(server, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewStoreTransactionRequestWithBody generates requests for StoreTransaction with any type of body
func NewStoreTransactionRequestWithBody(server string, params *StoreTransactionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/transactions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewListAttachmentByTransactionRequest generates requests for ListAttachmentByTransaction
func NewListAttachmentByTransactionRequest(server string, id string, params *ListAttachmentByTransactionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/transactions/%s/attachments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// StoreAttachmentWithBodyWithResponse request with any body
	StoreAttachmentWithBodyWithResponse(ctx context.Context, params *StoreAttachmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreAttachmentResponse, error)

	StoreAttachmentWithResponse(ctx context.Context, params *StoreAttachmentParams, body StoreAttachmentJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreAttachmentResponse, error)

	StoreAttachmentWithFormdataBodyWithResponse(ctx context.Context, params *StoreAttachmentParams, body StoreAttachmentFormdataRequestBody, reqEditors ...RequestEditorFn) (*StoreAttachmentResponse, error)

	// UploadAttachmentWithBodyWithResponse request with any body
	UploadAttachmentWithBodyWithResponse(ctx context.Context, id string, params *UploadAttachmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadAttachmentResponse, error)

	// SearchTransactionsWithResponse request
	SearchTransactionsWithResponse(ctx context.Context, params *SearchTransactionsParams, reqEditors ...RequestEditorFn) (*SearchTransactionsResponse, error)

	// StoreTransactionWithBodyWithResponse request with any body
	StoreTransactionWithBodyWithResponse(ctx context.Context, params *StoreTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreTransactionResponse, error)

	StoreTransactionWithResponse(ctx context.Context, params *StoreTransactionParams, body StoreTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreTransactionResponse, error)

	StoreTransactionWithFormdataBodyWithResponse(ctx context.Context, params *StoreTransactionParams, body StoreTransactionFormdataRequestBody, reqEditors ...RequestEditorFn) (*StoreTransactionResponse, error)

	// ListAttachmentByTransactionWithResponse request
	ListAttachmentByTransactionWithResponse(ctx context.Context, id string, params *ListAttachmentByTransactionParams, reqEditors ...RequestEditorFn) (*ListAttachmentByTransactionResponse, error)
}

type StoreAttachmentResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *AttachmentSingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON422                  *ValidationErrorResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r StoreAttachmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StoreAttachmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadAttachmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON422      *ValidationErrorResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r UploadAttachmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadAttachmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchTransactionsResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *TransactionArray
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r SearchTransactionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchTransactionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StoreTransactionResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *TransactionSingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON422                  *ValidationErrorResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r StoreTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StoreTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAttachmentByTransactionResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *AttachmentArray
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r ListAttachmentByTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAttachmentByTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// StoreAttachmentWithBodyWithResponse request with arbitrary body returning *StoreAttachmentResponse
func (c *ClientWithResponses) StoreAttachmentWithBodyWithResponse(ctx context.Context, params *StoreAttachmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreAttachmentResponse, error) {
	rsp, err := c.StoreAttachmentWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreAttachmentResponse(rsp)
}

func (c *ClientWithResponses) StoreAttachmentWithResponse(ctx context.Context, params *StoreAttachmentParams, body StoreAttachmentJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreAttachmentResponse, error) {
	rsp, err := c.StoreAttachment(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreAttachmentResponse(rsp)
}

func (c *ClientWithResponses) StoreAttachmentWithFormdataBodyWithResponse(ctx context.Context, params *StoreAttachmentParams, body StoreAttachmentFormdataRequestBody, reqEditors ...RequestEditorFn) (*StoreAttachmentResponse, error) {
	rsp, err := c.StoreAttachmentWithFormdataBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreAttachmentResponse(rsp)
}

// UploadAttachmentWithBodyWithResponse request with arbitrary body returning *UploadAttachmentResponse
func (c *ClientWithResponses) UploadAttachmentWithBodyWithResponse(ctx context.Context, id string, params *UploadAttachmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadAttachmentResponse, error) {
	rsp, err := c.UploadAttachmentWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadAttachmentResponse(rsp)
}

// SearchTransactionsWithResponse request returning *SearchTransactionsResponse
func (c *ClientWithResponses) SearchTransactionsWithResponse(ctx context.Context, params *SearchTransactionsParams, reqEditors ...RequestEditorFn) (*SearchTransactionsResponse, error) {
	rsp, err := c.SearchTransactions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchTransactionsResponse(rsp)
}

// StoreTransactionWithBodyWithResponse request with arbitrary body returning *StoreTransactionResponse
func (c *ClientWithResponses) StoreTransactionWithBodyWithResponse(ctx context.Context, params *StoreTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreTransactionResponse, error) {
	rsp, err := c.StoreTransactionWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreTransactionResponse(rsp)
}

func (c *ClientWithResponses) StoreTransactionWithResponse(ctx context.Context, params *StoreTransactionParams, body StoreTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreTransactionResponse, error) {
	rsp, err := c.StoreTransaction(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreTransactionResponse(rsp)
}

func (c *ClientWithResponses) StoreTransactionWithFormdataBodyWithResponse(ctx context.Context, params *StoreTransactionParams, body StoreTransactionFormdataRequestBody, reqEditors ...RequestEditorFn) (*StoreTransactionResponse, error) {
	rsp, err := c.StoreTransactionWithFormdataBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreTransactionResponse(rsp)
}

// ListAttachmentByTransactionWithResponse request returning *ListAttachmentByTransactionResponse
func (c *ClientWithResponses) ListAttachmentByTransactionWithResponse(ctx context.Context, id string, params *ListAttachmentByTransactionParams, reqEditors ...RequestEditorFn) (*ListAttachmentByTransactionResponse, error) {
	rsp, err := c.ListAttachmentByTransaction(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAttachmentByTransactionResponse(rsp)
}

// ParseStoreAttachmentResponse parses an HTTP response from a StoreAttachmentWithResponse call
func ParseStoreAttachmentResponse(rsp *http.Response) (*StoreAttachmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StoreAttachmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AttachmentSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUploadAttachmentResponse parses an HTTP response from a UploadAttachmentWithResponse call
func ParseUploadAttachmentResponse(rsp *http.Response) (*UploadAttachmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadAttachmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSearchTransactionsResponse parses an HTTP response from a SearchTransactionsWithResponse call
func ParseSearchTransactionsResponse(rsp *http.Response) (*SearchTransactionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchTransactionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TransactionArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseStoreTransactionResponse parses an HTTP response from a StoreTransactionWithResponse call
func ParseStoreTransactionResponse(rsp *http.Response) (*StoreTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StoreTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TransactionSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAttachmentByTransactionResponse parses an HTTP response from a ListAttachmentByTransactionWithResponse call
func ParseListAttachmentByTransactionResponse(rsp *http.Response) (*ListAttachmentByTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAttachmentByTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AttachmentArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}
